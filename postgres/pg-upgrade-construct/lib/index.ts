import { Construct } from "constructs"
import { Duration, CustomResource } from "aws-cdk-lib"
import * as cdk from "aws-cdk-lib"
import * as ec2 from "aws-cdk-lib/aws-ec2"
import * as cb from "aws-cdk-lib/aws-codebuild"
import * as kms from "aws-cdk-lib/aws-kms"
import * as iam from "aws-cdk-lib/aws-iam"
import * as lambda from "aws-cdk-lib/aws-lambda"
import * as rds from "aws-cdk-lib/aws-rds"
import * as s3 from "aws-cdk-lib/aws-s3"
import * as cr from "aws-cdk-lib/custom-resources"
import * as s3Deploy from "aws-cdk-lib/aws-s3-deployment"
import { spawnSync } from "child_process"
import * as path from "path"
import * as fs from "fs-extra"
import { NagSuppressions } from "cdk-nag"

/**
 * PgUpgrade Construct configuration properties.
 */
export interface PgUpgradeProps {

    /**
     * The folder where your schema change scripts are located.
     * See documentation for the `pg-upgrade` package.
     */
    readonly schemaFolder: string,

    /**
     * Specify a folder that can be used for build artifacts generated by this construct.
     *
     * This should be a dedicated, gitignored folder in the same place as your CDK app.
     */
    readonly buildFolder: string,

    /**
     * Log verbose output when running the CodeBuild job.
     */
    readonly verbose: boolean,
    
    /**
     * The VPC where your database is located.
     */
    readonly vpc: ec2.IVpc, 

    /**
     * The RDS cluster.
     */
    readonly cluster: rds.DatabaseCluster, 

    /**
     * Secrets manager endpoint.
     */
    readonly secretsEndpoint: ec2.IInterfaceVpcEndpoint, 

    /**
     * Security groups associated with the database.
     */
    readonly securityGroups: [], 

    /**
     * The region where the database is located.
     */
    readonly region: string, 

    /**
     * The schema name within the database.
     *
     * Default is "public"
     */
    readonly schemaName: string
}

/**
 * Postgresql Schema Upgrade.
 *
 */
export class PgUpgrade extends Construct {

    constructor(scope: Construct, id: string, props: PgUpgradeProps) {
        super(scope, id)

        if (props.schemaFolder === props.buildFolder) {
            throw new Error("schemaFolder and buildFolder cannot be the same")
        }

        const cluster = props.cluster
        const vpc = props.vpc

        // Create a bucket to hold access logs for the other buckets
        const logBucket = new s3.Bucket(this, "access-logs", {
            encryption: s3.BucketEncryption.S3_MANAGED,
            autoDeleteObjects: true,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
            blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
            enforceSSL: true
        })

        // Suppress nag error since this is the log bucket itself.
        NagSuppressions.addResourceSuppressions(logBucket, [
            { id: "AwsSolutions-S1", reason: "This is the log bucket" },
        ])

        // Bucket to hold the source code for the CodeBuild job
        const sourceBucket = new s3.Bucket(this, "source", {
            encryption: s3.BucketEncryption.S3_MANAGED,
            autoDeleteObjects: true,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
            blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
            enforceSSL: true,
            serverAccessLogsBucket: logBucket,
            serverAccessLogsPrefix: "pg-upgrade-source",
        })

        // Shell out to populate the build folder
        packageLambdas(props.schemaFolder, props.buildFolder)

        // S3Deployment to ship the source
        const deployment = new s3Deploy.BucketDeployment(this, "deploy", {
            sources: [s3Deploy.Source.asset(props.buildFolder)], 
            destinationBucket: sourceBucket, 
            memoryLimit: 1028
        })

        // Helper function to create CodeBuild secret variables
        const secretVar = function(name:string):cb.BuildEnvironmentVariable {
            return {
                value: cluster.secret!.secretArn + ":" + name,
                type: cb.BuildEnvironmentVariableType.SECRETS_MANAGER
            }
        }

        // The build spec for the CodeBuild project
        const pgpass = "$PGHOST:$PGPORT:$PGDATABASE:$PGUSER:$PGPASSWORD"
        const buildSpec = {
            "version": "0.2",
            "phases": {
                "pre_build": {
                    "commands": [
                        `echo ${pgpass} > ~/.pgpass`,
                        "chmod 600 ~/.pgpass"
                    ]
                },
                "build": {
                    "commands": [
                        "./upgrade.sh",
                    ]
                }
            },
        }

        const dbEnv: any = {
            "PGHOST": secretVar("host"),
            "PGPORT": secretVar("port"),
            "PGDATABASE": secretVar("dbname"),
            "PGUSER": secretVar("username"),
            "PGPASSWORD": secretVar("password"),
            "PGSCHEMA": {
                value: props.schemaName || "public",
                type: cb.BuildEnvironmentVariableType.PLAINTEXT
            }
        }
        
        // Key for CodeBuild artifacts
        const codeBuildKey = new kms.Key(this, 'cb-key', {
            enableKeyRotation: true,
        });

        // Create CodeBuild job to run the CLI
        const project = new cb.Project(this, "pg-upgrade", {
            vpc, 
            buildSpec: cb.BuildSpec.fromObject(buildSpec),
            source: cb.Source.s3({bucket: sourceBucket, path: "upgrade.zip"}), 
            timeout: Duration.minutes(480),
            encryptionKey: codeBuildKey,
            environment: {
                buildImage: cb.LinuxBuildImage.AMAZON_LINUX_2_3,
                environmentVariables: dbEnv,
                computeType: cb.ComputeType.X2_LARGE
            }
        })

        for (const sg of props.securityGroups) {
            project.connections.allowTo(sg, ec2.Port.tcp(5432))
        }

        cluster.secret!.grantRead(project)

        project.node.addDependency(deployment)

        const lambdaEnv = {
            "DB_SECRET_ARN": cluster.secret!.secretArn,
            "REGION": props.region,
            "SECRETS_ENDPOINT": `https://secretsmanager.${props.region}.amazonaws.com`,
            "PROJECT_NAME": project.projectName, 
            "PGSCHEMA": props.schemaName || "public", 
            "VERBOSE": "true"
        }

        // Lambda function to invoke the CodeBuild job on each deploy
        const invokerLambda = new lambda.Function(this, "invoker", {
            runtime: lambda.Runtime.NODEJS_16_X,
            code: lambda.Code.fromAsset(props.buildFolder),
            handler: "invoker.handler",
            vpc,
            memorySize: 1024,
            timeout: Duration.minutes(15),
            securityGroups: props.securityGroups,
            environment: lambdaEnv,
        })

        invokerLambda.addToRolePolicy(
            new iam.PolicyStatement({
                actions: ["codebuild:StartBuild"],
                resources: [project.projectArn],
                effect: iam.Effect.ALLOW,
            })
        )

        // Lambda function to check to see if the upgrade is complete
        const isCompleteLambda = new lambda.Function(this, "is-complete", {
            runtime: lambda.Runtime.NODEJS_16_X,
            code: lambda.Code.fromAsset(props.buildFolder),
            handler: "is-complete.handler",
            vpc,
            memorySize: 1024,
            timeout: Duration.minutes(15),
            securityGroups: props.securityGroups,
            environment: lambdaEnv,
        })

        // Allow the lambda to read the database secret
        isCompleteLambda.addToRolePolicy(
            new iam.PolicyStatement({
                actions: ["secretsmanager:GetSecretValue"], 
                resources: [cluster.secret!.secretArn],
                effect: iam.Effect.ALLOW,
            })
        )

        // Canary Lambda to run integration tests on the database after deployment
        // (optional)
        // Role to allow the CI/CD account to call the canary
        // Output the function name

        // Custom resource provider
        const provider = new cr.Provider(this, "up-invoke-prov", {
            onEventHandler: invokerLambda,
            isCompleteHandler: isCompleteLambda,
        })

        // Custom resource to force an update
        const customResource = new CustomResource(this, "up-invoke-res", {
            serviceToken: provider.serviceToken,
            properties: {"FORCE_UPDATE": new Date().toISOString()},
        })

        customResource.node.addDependency(project)
        //        canaryLambda.node.addDependency(customResource)

    }
}

/**
 * Shell out to run webpack on the lambda folder, add the user's source files, 
 * and create a zip for CodeBuild.
 */
function packageLambdas(schemaFolder:string, buildFolder: string) {

    // When this runs as part of integ tests, dirname is the source directory, 
    // but when it runs as a dependency of another construct, dirname is 
    // in the packaged directory which has a different structure.

    let relativePath = "../../"
     
    let cmd = path.join(__dirname, relativePath, "scripts/package.sh")
    if (!fs.existsSync(cmd)) {
        // Running as a local test
        relativePath = "../"
        cmd = path.join(__dirname, relativePath, "scripts/package.sh")
    }
    const args = [schemaFolder, buildFolder]
    const opts:any = {
        cwd: path.join(__dirname, relativePath)  
    }
    const proc = spawnSync(cmd, args, opts)

    if (proc.error) {
        throw proc.error
    }

    if (proc.status !== 0) {
        const msg = `${cmd} ${args.join(" ")} 
${opts?.cwd ? `run in directory ${opts.cwd}` : ""} 
exited with status ${proc.status}`

        if (proc.stdout || proc.stderr) {
            const outmsg = `[${proc.status}]: ${proc.stdout?.toString().trim()}`
            const errmsg = `Error: ${proc.stderr?.toString().trim()}`
            throw new Error(`${msg}\n${outmsg}\n${errmsg}`)
        }
        throw new Error(msg)
    }

    console.log(proc.stdout?.toString().trim())

}

